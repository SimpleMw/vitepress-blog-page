import{_ as a,C as l,o as i,c as s,k as t,H as r,w as d,a as e,Q as n}from"./chunks/framework.8153c8a6.js";const b=JSON.parse('{"title":"GET和POST","description":"","frontmatter":{"title":"GET和POST","date":"2020-11-12T16:34:11.000Z"},"headers":[],"relativePath":"guide/springbasic/GET和POST.md","filePath":"guide/springbasic/GET和POST.md"}'),p={name:"guide/springbasic/GET和POST.md"},c={id:"web提交",tabindex:"-1"},T=t("a",{class:"header-anchor",href:"#web提交","aria-label":'Permalink to "<font color=red>web提交</font>"'},"​",-1),_=n('<h5 id="get提交" tabindex="-1">get提交 <a class="header-anchor" href="#get提交" aria-label="Permalink to &quot;get提交&quot;">​</a></h5><ul><li>一般用于查询和删除，若条件数据较多，如in方式的则使用post</li></ul><h5 id="post提交" tabindex="-1">post提交 <a class="header-anchor" href="#post提交" aria-label="Permalink to &quot;post提交&quot;">​</a></h5><ul><li>一般用于新增和更新</li><li>一般使用pojo去接收传进来的数据， <ul><li>若需要一个 &lt;Pojo 的对象，可以在原pojo上添加 @Builder 注解，通过建造者模式链式构建对象来处理</li><li>若需要一个 &gt;Pojo 的对象，3种处理方式 <ul><li>通过map的方式去接收 添加注解 (@RequestBody表示处理post提交的body)；</li><li>新建个 PojoVo类来装请求数据(新增一个 Pojo扩容类)；</li><li>直接对原来的Pojo扩容其它使用原pojo的则使用建造者模式链式构建对象(不推荐)；</li></ul></li></ul></li></ul><p>两者优缺点</p><ul><li>网上的举例</li></ul><p>tcp类比汽车，http类比交通规则，而GET、POST则为服务级别；GET请求为 货物需放在车顶上(url)方便记录，且贴上Get标签(method为GET)；POST请求为 货物放在箱体(Body)中，且贴上Post标签(method为POST)；也有GET请求在箱体内偷偷放东西的，也有POST请求放一些货物放在车顶的；由于符合交通规则，GET也可以在车顶无限放货物；浏览器和服务器类比于运输公司，由于装货和卸货都是浏览器和服务器干的，所以浏览器和一些服务器都规定车顶上放的货物有一个限制，超出部分不处理(url的大小有规定，超出的数据不处理)；当然如果GET请求箱体内放点东西，有些服务器也会好心的帮你处理下</p><p>GET和POST其实没啥区别，只是受限制于浏览器和服务器</p><ul><li><p>请求的时候 GET请求只跑一次 header和data一次运输，服务器响应200；POST跑两次先header过去服务器响应100，然后data过去服务器响应200</p></li><li><p>get提交不安全，数据都放在url种，且请求数据大小有限制，但是前端逻辑简单，请求数据也很直观</p></li><li><p>浏览器回退，get提交无危害，post会再次请求</p></li></ul>',9);function u(h,P,m,S,f,E){const o=l("font");return i(),s("div",null,[t("h4",c,[r(o,{color:"red"},{default:d(()=>[e("web提交")]),_:1}),e(),T]),_])}const g=a(p,[["render",u]]);export{b as __pageData,g as default};
