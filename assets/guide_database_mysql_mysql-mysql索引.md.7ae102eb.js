import{_ as l,o as i,c as a,Q as e}from"./chunks/framework.8153c8a6.js";const q=JSON.parse('{"title":"mysql索引","description":"","frontmatter":{"title":"mysql索引","date":"2022-09-15T09:34:36.000Z"},"headers":[],"relativePath":"guide/database/mysql/mysql-mysql索引.md","filePath":"guide/database/mysql/mysql-mysql索引.md"}'),t={name:"guide/database/mysql/mysql-mysql索引.md"},s=e('<h5 id="b-树" tabindex="-1">B+树 <a class="header-anchor" href="#b-树" aria-label="Permalink to &quot;B+树&quot;">​</a></h5><ul><li>存储引擎与磁盘的交互是以page页的形式，page页的数据存储大小是16k</li><li>B+树就是将page页的位置信息生成目录 <ul><li>目录记录的主要参数是 序号开始、页码</li><li>然后又对目录按同样的方式创建目录</li></ul></li></ul><p>注：</p><ul><li>创建目录的层级越高，存储引擎与磁盘的交互次数就越多(查询时间就越长)</li><li>对于大数据字段，由于数据会保存在多个page页中，会导致目录的层级变高</li><li>若B+树根据的字段是无序的，则每次新增或修改会导致更多次的B+树的分裂和合并</li></ul><h5 id="索引分类" tabindex="-1">索引分类 <a class="header-anchor" href="#索引分类" aria-label="Permalink to &quot;索引分类&quot;">​</a></h5><ul><li>主键索引</li></ul><p>表设置主键后，会根据主键生成B+树</p><ul><li>聚集索引 <ul><li>表未设置主键后会自动创建聚集索引，会根据聚集索引生成B+树</li><li>以非空的唯一索引字段作为聚集索引，若非空的唯一索引也没有则会以rowid做为聚集索引</li></ul></li></ul><p>二级索引</p><ul><li><p>联合索引</p><ul><li>多个字段保证唯一创建B+树</li><li>联合索引的好处是不用进行回表 <ul><li>若查询的字段在联合索引之中，则只需要查询联合索引B+树的目录层级</li><li>若查询的字段不在联合索引之中，则从目录层级获取到联合索引存在的字段后，还要去查询主键索引或聚集索引</li></ul></li></ul></li><li><p>覆盖索引</p><ul><li>叶子节点保存主键的值，当需要查询的值不在联合索引中的时候会直接去读取覆盖索引</li><li>使用覆盖索引会减少回表次数</li></ul></li></ul><p>注：</p><ul><li><p>创建索引一定需要避免用 散列性不强 的字段作为索引，即若多个数据该字段都是同样的数据，在进行B+树寻找的时候，找到的范围会很大，索引的作用就不大了</p></li><li><p>面试题：</p><ul><li>为什么一张表的数据达到500万后建议分库分表？</li></ul><p>答：500万数据的表建立索引后，B+树的层级会变得很高，当进行查询的时候，数据引擎与磁盘的交互次数会变得很多，查询效率低</p></li></ul>',12),u=[s];function p(o,r,_,d,n,c){return i(),a("div",null,u)}const h=l(t,[["render",p]]);export{q as __pageData,h as default};
