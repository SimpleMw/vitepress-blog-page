import{_ as t,o as e,c as a,Q as r}from"./chunks/framework.8153c8a6.js";const b=JSON.parse('{"title":"web相关复习","description":"","frontmatter":{"title":"web相关复习","date":"2020-10-04T13:25:25.000Z","category":"java基础相关","tag":"java","top_img":false},"headers":[],"relativePath":"guide/javabasic/web作用域.md","filePath":"guide/javabasic/web作用域.md"}'),l={name:"guide/javabasic/web作用域.md"},i=r('<p>javaweb 三大组件 Servlet，Filter，Listener</p><h2 id="servlet" tabindex="-1">Servlet <a class="header-anchor" href="#servlet" aria-label="Permalink to &quot;Servlet&quot;">​</a></h2><h3 id="生命周期四个阶段" tabindex="-1">生命周期四个阶段： <a class="header-anchor" href="#生命周期四个阶段" aria-label="Permalink to &quot;生命周期四个阶段：&quot;">​</a></h3><ul><li><p>实例化：调用构造方法</p></li><li><p>初始化：调用init()方法</p></li><li><p>处理请求：调用service()方法</p></li><li><p>销毁：调用destroy()方法</p></li></ul><h3 id="使用servlet方式" tabindex="-1">使用Servlet方式 <a class="header-anchor" href="#使用servlet方式" aria-label="Permalink to &quot;使用Servlet方式&quot;">​</a></h3><p>实现方式：继承httpServlet类，重写doPost()、doGet()方法；</p><p>实现原理：HttpServlet的service(HttpServletRequest,HttpServletResponse)方法会去判断当前请求是GET还是POST，如果是GET请求，那么会去调用本类的doGet()方法，如果是POST请求会去调用doPost()方法</p><h3 id="jsp和servlet" tabindex="-1">Jsp和Servlet <a class="header-anchor" href="#jsp和servlet" aria-label="Permalink to &quot;Jsp和Servlet&quot;">​</a></h3><ul><li>Jsp就是后缀为jsp的文件，即是HTML中写java代码</li><li>Servlet 在javaweb开发中主要的功能为 处理请求和发送响应</li><li>两者的区别是 <ul><li>Jsp是在HTML中写java代码 ，servlet是java代码中写HTML</li><li>Jsp是先部署后编译，servlet是先编译后部署</li></ul></li></ul><h2 id="fileter-过滤器" tabindex="-1">Fileter 过滤器 <a class="header-anchor" href="#fileter-过滤器" aria-label="Permalink to &quot;Fileter 过滤器&quot;">​</a></h2><h3 id="使用filter方式" tabindex="-1">使用Filter方式 <a class="header-anchor" href="#使用filter方式" aria-label="Permalink to &quot;使用Filter方式&quot;">​</a></h3><p>实现方法：实现Filter接口，重新doFiler()方法</p><p>实现原理：对配置的拦截的url的request和response进行修改</p><h3 id="过滤器和拦截器的区别" tabindex="-1">过滤器和拦截器的区别 <a class="header-anchor" href="#过滤器和拦截器的区别" aria-label="Permalink to &quot;过滤器和拦截器的区别&quot;">​</a></h3><ul><li>拦截器是基于java的反射机制的，而过滤器是基于函数回调。</li><li>拦截器是spring的一个组件不依赖与servlet容器，过滤器依赖与servlet容器。</li><li>拦截器能应用于所有的方法前后以及异常抛出前后，而过滤器只在servlet前后其作用</li></ul><h2 id="listener-监听器" tabindex="-1">Listener 监听器 <a class="header-anchor" href="#listener-监听器" aria-label="Permalink to &quot;Listener 监听器&quot;">​</a></h2><p>监听器是对某个对象的监听，一般是监听其创建、销毁以及改变</p><ul><li><strong>ServletContext对象监听器</strong></li><li><strong>HttpSession对象监听器</strong></li><li><strong>ServletRequest对象监听器</strong></li></ul><p>使用Listener方式</p><p>实现方法：例 实现HttpSessionListener 接口，重写sessionCreated()方法或者sessionDestroyed()方法监听创建和销毁</p><h2 id="四大作用域" tabindex="-1">四大作用域 <a class="header-anchor" href="#四大作用域" aria-label="Permalink to &quot;四大作用域&quot;">​</a></h2><ul><li><p>page域</p><p>Jsp页面使用</p></li><li><p>request域</p><p>一个请求到转发的周期</p></li><li><p>session域</p><p>从打开浏览器到关闭浏览器，可以有多个请求</p></li><li><p>application域</p><p>应用启动到应用结束，所有用户共享application中的变量</p></li></ul><h2 id="九大内置对象" tabindex="-1">九大内置对象 <a class="header-anchor" href="#九大内置对象" aria-label="Permalink to &quot;九大内置对象&quot;">​</a></h2><table><thead><tr><th>对象</th><th>解释</th><th>作用域</th><th>类型</th><th>在Servlet中如何获得</th></tr></thead><tbody><tr><td>application</td><td>应用程序对象</td><td>Application</td><td>javax.servlet.ServletContext</td><td>this.getServletContext()</td></tr><tr><td>session</td><td>会话对象</td><td>Session</td><td>javax.servlet.http.HttpSession</td><td>requset.getSession()</td></tr><tr><td>request</td><td>请求对象</td><td>Request</td><td>javax.servlet.ServletRequest</td><td>service方法中的request参数</td></tr><tr><td>response</td><td>响应对象</td><td>Page</td><td>javax.servlet.SrvletResponse</td><td>service方法中的response参数</td></tr><tr><td>pageContext</td><td>页面上下文对象</td><td>Page</td><td>javax.servlet.jsp.PageContext</td><td>不能在servlet中使用，可以获得其他对象</td></tr><tr><td>out</td><td>输出对象</td><td>Page</td><td>javax.servlet.jsp.JspWriter</td><td>response.getWriter&lt;注意这里类型是printWriter&gt;</td></tr><tr><td>config</td><td>配置对象</td><td>Page</td><td>javax.servlet.ServletConfig</td><td>this.getServletConfig()</td></tr><tr><td>page</td><td>页面对象</td><td>Page</td><td>javax.lang.Object</td><td>this</td></tr><tr><td>exception</td><td>异常对象</td><td>Page</td><td>javax.lang.Throwable</td><td>new Throwable();</td></tr></tbody></table>',24),d=[i];function s(o,n,p,h,v,c){return e(),a("div",null,d)}const g=t(l,[["render",s]]);export{b as __pageData,g as default};
