import{_ as o,C as n,o as r,c as s,k as a,a as l,H as i,w as t,Q as c}from"./chunks/framework.8153c8a6.js";const S=JSON.parse('{"title":"java各种锁","description":"","frontmatter":{"title":"java各种锁","date":"2021-03-02T16:34:11.000Z","category":"java基础相关","tags":"锁","top_img":false},"headers":[],"relativePath":"guide/javabasic/锁.md","filePath":"guide/javabasic/锁.md"}'),d={name:"guide/javabasic/锁.md"},h=c("",23),p=a("h6",{id:"锁消除",tabindex:"-1"},[l("锁消除 "),a("a",{class:"header-anchor",href:"#锁消除","aria-label":'Permalink to "锁消除"'},"​")],-1),u=a("p",null,"若对象中存在 加了synchronized同步字段的方法，若jvm判断该对象不可能被其它线程引用，则jvm会自动优化，会自动消除对象内部的锁 如：StringBuffer",-1),_=a("h6",{id:"锁粗化",tabindex:"-1"},[l("锁粗化 "),a("a",{class:"header-anchor",href:"#锁粗化","aria-label":'Permalink to "锁粗化"'},"​")],-1),m=a("p",null,"若对象中存在 加了synchronized同步字段的方法，若该对象被多次加锁(循环)，则jvm会将加锁操作粗化到循环外部",-1),f=a("h5",{id:"synchronized",tabindex:"-1"},[l("synchronized "),a("a",{class:"header-anchor",href:"#synchronized","aria-label":'Permalink to "synchronized"'},"​")],-1),b=a("p",null,"实现原理：java原生地实现锁，即是线程将线程id写入到对象地markword中，哪个线程写入了，就哪个线程抢到了锁",-1),k=a("p",null,"三个层面解析synchronized：",-1),x=a("ul",null,[a("li",null,[a("p",null,"代码层面 即synchronized修饰方法或者代码块")]),a("li",null,[a("p",null,"字节码层面 被synchronized修饰的代码块，在字节码层面是 用monitorenter和monitorexit这两个命令来实现加锁和解锁的")]),a("li",null,[a("p",null,"汇编层面 即lock修饰，CAS的原理在此处的实现命令 cmpxchg，即比较改变，lock来修饰 cmpxchg保证原子性")])],-1);function g(v,P,q,j,y,z){const e=n("font");return r(),s("div",null,[h,a("p",null,[l("注：轻量级锁-->重量级锁 原因：等待的线程太多了，将未获取到锁的线程放入 "),i(e,{color:"red"},{default:t(()=>[l("等待状态")]),_:1})]),p,u,_,m,i(e,{color:"red"},{default:t(()=>[l("借鉴[出处](https://tech.meituan.com/2018/11/15/java-lock.html)")]),_:1}),f,b,k,x])}const T=o(d,[["render",g]]);export{S as __pageData,T as default};
