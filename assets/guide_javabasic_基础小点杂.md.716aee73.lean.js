import{_ as t,C as e,o as c,c as r,H as n,w as l,Q as o,k as s,a as p}from"./chunks/framework.a0a80147.js";const ss=JSON.parse('{"title":"基础小点杂","description":"","frontmatter":{"title":"基础小点杂","date":"2020-10-01T08:34:36.000Z","category":"java基础相关","tag":"java","top_img":false},"headers":[],"relativePath":"guide/javabasic/基础小点杂.md","filePath":"guide/javabasic/基础小点杂.md"}'),E={name:"guide/javabasic/基础小点杂.md"},y=o("",2),i=s("p",null,"break 跳出循环，无下次循环",-1),d=s("p",null,"continue 终止当前循环，有下次循环",-1),u=s("p",null,"同一个类终，方法名相同，参数列表不同",-1),_=s("p",null,"子类继承父类时，对父类的方法进行重新覆写",-1),F=s("p",null,"方法名、返回值类型、形参相同；访问权限>=重写前；抛出异常<=重写前",-1),g=o("",4),h=o("",3),C=s("p",null,"栈：声明的名字存在 栈中 main()方法是存在栈里面的，基本数据类型是存在栈中的",-1),v=s("p",null,"堆：new创建的时候开辟内存空间 也即对象是存在堆中的",-1),b=s("ul",null,[s("li",null,[s("p",null,"构造器的名字与类名相同，无返回值")]),s("li",null,[s("p",null,"默认存在一个无参构造器，若存在一个有参构造器，则默认的无参构造器就不存在了")]),s("li",null,[s("p",null,"new方法时，本质是在调用构造器(首先调用父类的构造器，然后调用子类的构造器，且必须调用父类的构造方法)")]),s("li",null,[s("p",null,"构造器的作用是初始化值")])],-1),A=s("p",null,"this：谁调用代表谁 super：代表父类",-1),B=s("p",null,"this() 调用本类的构造方法 super()调用父类的构造方法",-1),m=s("ul",null,[s("li",null,[s("p",null,"抽象类的方法必须由其非抽象子类实现")]),s("li",null,[s("p",null,"抽象类中可以有普通方法")]),s("li",null,[s("p",null,"抽象类有构造方法，但是没有方法实现，也即不能使用new实例化，构造方法用来初始化")])],-1),S=s("ul",null,[s("li",null,[s("p",null,"接口中的方法无实现")]),s("li",null,[s("p",null,"接口中方法默认为public")]),s("li",null,[s("p",null,"类实现接口 implements")]),s("li",null,[s("p",null,"若实现的多个接口中存在多个相同的方法，则实现类中只会出现一个")]),s("li",null,[s("p",null,"接口中的常量默认为 public static final")]),s("li",null,[s("p",null,"接口中无构造方法")])],-1),D=s("p",null,"子类继承了父类的所有方法和成员，但对私有的无权限调用",-1),T=s("p",null,"当一个基础数据类型与封装类进行==、+、-、*、/运算时，会将封装类进行拆箱，对基础数据类型进行运算。",-1),q=s("ul",null,[s("li",null,"JDK包含jre"),s("li",null,"JDK是面向开发人员使用的SDK，jre是Java Runtime Enviroment运行环境是面向java程序的使用者")],-1),k=s("p",null,"== 和 equals 的区别",-1),f=s("ul",null,[s("li",null,"== 比较的地址"),s("li",null,"equals 比较的是值")],-1),I=s("ul",null,[s("li",null,"hashcode()返回的是一个hash值，是为了方便查找"),s("li",null,"equals() 是用于比较"),s("li",null,"equals()比较为 true时，他们的hash值必定相同；equals()比较不同时，他们的hash值也可能相同(数据碰撞的情况)")],-1),j=s("p",null,"hash碰撞",-1),P=s("p",null,"将任意长度的数据 经过算法 转为 一段有限长度的数据 （无穷转有限，必定会出现碰撞，对于我们用到的遇到碰撞却很小）",-1),V=s("p",null,"在集合中的应用（集合分为list、set，list有序可重复，set无序不可重复）",-1),w=s("p",null,"在set中保证不重复，首先会比较hash值，若hash值不同，则必定不重复;若hash值相同，则根据equals()比较，不同则不重复，相同则重复",-1),W=s("p",null,"将10进制以二进制（基数 2）无符号整数形式返回一个整数参数的字符串表示形式。 如果参数为负，该无符号整数值为参数加上 2^32；否则等于该参数。",-1),N=o("",12),R=o("",2),M=o("",1),U=o("",1),L=o("",1),x=o("",1),J=o("",1),K=o("",1),$=o("",10);function H(O,Q,Z,z,G,X){const a=e("font");return c(),r("div",null,[n(a,{color:"dd0000"},{default:l(()=>[p("Scanner")]),_:1}),y,n(a,{color:"dd0000"},{default:l(()=>[p("循环 break 和 continue")]),_:1}),i,d,n(a,{color:"dd0000"},{default:l(()=>[p("方法重载")]),_:1}),u,n(a,{color:"dd0000"},{default:l(()=>[p("方法重写")]),_:1}),_,F,n(a,{color:"dd0000"},{default:l(()=>[p("可变参数")]),_:1}),g,n(a,{color:"dd0000"},{default:l(()=>[p("数组 数组的大小是不可变的")]),_:1}),h,n(a,{color:"dd0000"},{default:l(()=>[p("堆栈")]),_:1}),C,v,n(a,{color:"dd0000"},{default:l(()=>[p("构造器")]),_:1}),b,n(a,{color:"dd0000"},{default:l(()=>[p("this与super")]),_:1}),A,B,n(a,{color:"dd0000"},{default:l(()=>[p("抽象类")]),_:1}),m,n(a,{color:"dd0000"},{default:l(()=>[p("接口")]),_:1}),S,n(a,{color:"dd0000"},{default:l(()=>[p("继承")]),_:1}),D,n(a,{color:"dd0000"},{default:l(()=>[p("类 单继承，多实现；接口多继承")]),_:1}),n(a,{color:"dd0000"},{default:l(()=>[p("匿名内部类 new 接口")]),_:1}),n(a,{color:"dd0000"},{default:l(()=>[p("自动拆箱")]),_:1}),T,n(a,{color:"dd0000"},{default:l(()=>[p("JDK 和 jre区别")]),_:1}),q,k,f,n(a,{color:"dd0000"},{default:l(()=>[p("hashCode()和equals()联系")]),_:1}),I,j,P,V,w,n(a,{color:"dd0000"},{default:l(()=>[p("Integer.toBinaryString()函数")]),_:1}),W,n(a,{color:"dd0000"},{default:l(()=>[p("位运算")]),_:1}),N,n(a,{color:"dd0000"},{default:l(()=>[p("进制转换")]),_:1}),R,n(a,{color:"dd0000"},{default:l(()=>[p("补位")]),_:1}),M,n(a,{color:"dd0000"},{default:l(()=>[p("排序")]),_:1}),U,n(a,{color:"dd0000"},{default:l(()=>[p("优雅获取执行时间")]),_:1}),L,n(a,{color:"dd0000"},{default:l(()=>[p("计算时间差")]),_:1}),x,n(a,{color:"dd0000"},{default:l(()=>[p("BigDecimal去掉后面多余的0")]),_:1}),J,n(a,{color:"dd0000"},{default:l(()=>[p("BigDecimal后面补0")]),_:1}),K,n(a,{color:"dd0000"},{default:l(()=>[p("注解")]),_:1}),$])}const as=t(E,[["render",H]]);export{ss as __pageData,as as default};
